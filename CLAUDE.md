# quickjs-emscripten

## Package Manager

Use `corepack pnpm` to run pnpm commands, e.g.:

- `corepack pnpm install`
- `corepack pnpm build`
- `corepack pnpm build:ts`

## Building Variants

Variants are WASM/JS builds of QuickJS with different configurations. They are generated by `scripts/prepareVariants.ts`.

To build a variant:

```bash
cd packages/variant-quickjs-<name>
make           # builds the C code with emscripten
corepack pnpm build:ts  # builds the TypeScript wrapper
```

## Emscripten

- Most variants use the default emscripten version (defined in `scripts/prepareVariants.ts` as `DEFAULT_EMSCRIPTEN_VERSION`)
- The asmjs variant uses an older emscripten version (`ASMJS_EMSCRIPTEN_VERSION`) to avoid newer browser APIs
- Emscripten runs via Docker when the local version doesn't match; see `scripts/emcc.sh`

## Testing

Run all tests:

```bash
corepack pnpm test
```

Run tests for a specific variant (e.g., quickjs-ng only):

```bash
cd packages/quickjs-emscripten
npx vitest run -t "quickjs-ng"
```

Other test filters:

- `-t "RELEASE_SYNC"` - only release sync variants
- `-t "DEBUG"` - only debug variants
- `-t "QuickJSContext"` - only sync context tests

## Git

- Never use `git commit --amend` - always create new commits. It's better to have a history of what was actually done since branches get rebased/squashed anyway when merged.
- Before pushing, run `pnpm run prettier` and `pnpm run lint` to fix formatting and lint issues. No need to check after every commit - just before pushing.

## CI Workflow

After pushing a PR, monitor CI using the `gh` CLI:

```bash
# Check CI status for a PR
gh pr checks <PR_NUMBER>

# View a specific job's progress
gh run view --job=<JOB_ID>

# Get logs for failed steps
gh run view <RUN_ID> --log-failed
```

When CI fails:
1. Get the failed logs with `gh run view <RUN_ID> --log-failed | tail -100`
2. Fix the issue locally
3. Commit the fix (new commit, don't amend)
4. Push and repeat until CI passes

The full CI build takes ~20 minutes due to emscripten compilation.

## Key Files

- `scripts/prepareVariants.ts` - Generates all variant packages from templates
- `scripts/generate.ts` - Generates FFI bindings and symbols
- `scripts/idl.ts` - Command buffer IDL definitions and C code generator
- `templates/Variant.mk` - Makefile template for variants
- `c/interface.c` - C interface to QuickJS exposed to JavaScript
- `c/command.h` - Command buffer structures (QTS_Command, QTS_CommandEnv)
- `c/perform_op.c` - Generated dispatcher for command execution
- `c/perform_*.h/c` - Generated op implementations (one per command)

## Command Buffer System (Ops)

The command buffer system allows batching multiple QuickJS operations into a single FFI call.

### Code Generation

Regenerate all C ops files:

```bash
pnpm run ops:c
# or directly: ./scripts/generate.ts c-ops c/
```

This generates:
- `c/op.h` - Opcode enum
- `c/perform_op.h/c` - Dispatcher
- `c/perform_*.h` - Op function declarations (always regenerated)
- `c/perform_*.c` - Op implementations (only created if missing, signatures updated if changed)

### IDL Structure (scripts/idl.ts)

Commands are defined in the `COMMANDS` object. Each command is exactly 16 bytes:

```typescript
COMMAND_NAME: {
  doc: "Description",
  slot_a: { name: "result", type: "JSValueSlot", ... },  // byte 1
  slot_b: { name: "obj", type: "JSValueSlot", ... },     // byte 2
  slot_c: { name: "flags", type: "JSPropFlags", ... },   // byte 3
  data: {                                                 // bytes 4-15
    type: "raw",  // or "f64", "i64", "buf", "jsvalues"
    d1: { name: "name_ptr", type: "char*", ... },
    d2: { name: "value", type: "uint32_t", ... },
  }
}
```

### Type System

Slot types (uint8_t): `JSValueSlot`, `FuncListSlot`, `JSPropFlags`

Data types (uint32_t): `uint32_t`, `int32_t`, `HostRefId`, `char*`, `Uint16Pair`

The generator automatically casts when extracting values from the command struct:
- Pointer types (`char*`): simple cast `(char*)cmd.data.raw.d1`
- Struct types (`Uint16Pair`): pointer reinterpret `*(Uint16Pair*)&cmd.data.raw.d3`

### Uint16Pair

Two uint16 values packed into one uint32. Used for passing two small values in one field.

```c
// In C, access via struct fields:
Uint16Pair pair = *(Uint16Pair*)&cmd.data.buf.extra;
uint16_t first = pair.low;   // bits 0-15
uint16_t second = pair.high; // bits 16-31
```

Memory layout (little-endian, which wasm always is): `[low_byte0, low_byte1, high_byte0, high_byte1]`

### Implementing an Op

1. Find your `c/perform_<name>.c` file (scaffold is auto-generated)
2. Replace `OP_UNIMPLEMENTED(env, "perform_<name>")` with implementation
3. Use `env->ctx` for JSContext, `env->jsvalue_slots[slot]` for JSValue access
4. Return `QTS_COMMAND_OK` on success, or use `OP_ERROR(env, "message")` on failure

## QuickJS C API Tips

### Value Ownership

QuickJS has strict ownership semantics. Functions either "consume" (take ownership of) or "borrow" values:

**Functions that CONSUME values (caller must NOT free afterward):**

- `JS_DefinePropertyValue` - consumes `val`
- `JS_DefinePropertyValueStr` - consumes `val`
- `JS_DefinePropertyValueUint32` - consumes `val`
- `JS_SetPropertyValue` - consumes `val`
- `JS_SetPropertyStr` - consumes `val`
- `JS_Throw` - consumes the error value

**Functions that DUP values internally (caller SHOULD free afterward):**

- `JS_NewCFunctionData` - calls `JS_DupValue` on data values, so free your reference after
- `JS_SetProperty` - dups the value

**Common double-free bug pattern:**

```c
// WRONG - double free!
JSValue val = JS_NewString(ctx, "hello");
JS_DefinePropertyValueStr(ctx, obj, "name", val, JS_PROP_CONFIGURABLE);
JS_FreeValue(ctx, val);  // BUG: val was already consumed!

// CORRECT
JSValue val = JS_NewString(ctx, "hello");
JS_DefinePropertyValueStr(ctx, obj, "name", val, JS_PROP_CONFIGURABLE);
// No JS_FreeValue needed - value is consumed
```

### quickjs vs quickjs-ng Differences

Some functions have different signatures between bellard/quickjs and quickjs-ng:

```c
// bellard/quickjs - class ID is global
JS_NewClassID(&class_id);

// quickjs-ng - class ID is per-runtime
JS_NewClassID(rt, &class_id);
```

Use `#ifdef QTS_USE_QUICKJS_NG` for compatibility:

```c
#ifdef QTS_USE_QUICKJS_NG
  JS_NewClassID(rt, &class_id);
#else
  JS_NewClassID(&class_id);
#endif
```

### Class Registration

- `JS_NewClassID` allocates a new class ID (only call once globally or per-runtime for ng)
- `JS_NewClass` registers the class definition with a runtime
- `JS_IsRegisteredClass` checks if a class is already registered with a runtime
- Class prototypes default to `JS_NULL` for new classes - set with `JS_SetClassProto` if needed

### Disposal Order

When disposing resources, order matters for finalizers:

```typescript
// CORRECT: Free runtime first so GC finalizers can call back to JS
const rt = new Lifetime(ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {
  ffi.QTS_FreeRuntime(rt_ptr);        // 1. Free runtime - runs GC finalizers
  callbacks.deleteRuntime(rt_ptr);     // 2. Then delete callbacks
});
```

### GC and Prevent Corruption Assertions

If you see assertions like:
- `Assertion failed: i != 0, at: quickjs.c, JS_FreeAtomStruct` - atom hash corruption (often double-free)
- `Assertion failed: list_empty(&rt->gc_obj_list)` - objects leaked
- `Assertion failed: p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT` - memory corruption

These usually indicate memory management bugs: double-frees, use-after-free, or missing frees.

### JSCFunctionListEntry and Property Definition Macros

QuickJS provides `JSCFunctionListEntry` for bulk-defining properties on objects using `JS_SetPropertyFunctionList`. **Always use the DEF macros from quickjs.h** instead of manually setting struct fields:

**Function definitions:**

```c
// Regular function with magic (for callbacks)
entry = (JSCFunctionListEntry)JS_CFUNC_MAGIC_DEF(name, length, func, magic);
entry.prop_flags = flags;  // Override if needed (macro defaults to WRITABLE|CONFIGURABLE)

// Constructor with magic
entry = (JSCFunctionListEntry)JS_CFUNC_SPECIAL_DEF(name, length, constructor_magic, func);
entry.prop_flags = flags;
entry.magic = magic;  // Must set separately (macro defaults to 0)

// Getter/setter
entry = (JSCFunctionListEntry)JS_CGETSET_DEF(name, getter, setter);
entry.prop_flags = flags;  // Override if needed (macro defaults to CONFIGURABLE)
```

**Property definitions (macros accept flags directly):**

```c
entry = (JSCFunctionListEntry)JS_PROP_STRING_DEF(name, str, flags);
entry = (JSCFunctionListEntry)JS_PROP_INT32_DEF(name, val, flags);
entry = (JSCFunctionListEntry)JS_PROP_INT64_DEF(name, val, flags);
entry = (JSCFunctionListEntry)JS_PROP_DOUBLE_DEF(name, val, flags);
entry = (JSCFunctionListEntry)JS_PROP_UNDEFINED_DEF(name, flags);
entry = (JSCFunctionListEntry)JS_OBJECT_DEF(name, tab, len, flags);
```

**Memory allocation for funclist arrays:**

```c
// Use QuickJS runtime allocator (tracked by runtime, freed on runtime cleanup)
JSCFunctionListEntry *entries = js_mallocz_rt(JS_GetRuntime(ctx), sizeof(JSCFunctionListEntry) * count);
// ...
js_free_rt(JS_GetRuntime(ctx), entries);
```

**Applying to an object:**

```c
JS_SetPropertyFunctionList(ctx, obj, entries, count);
```

## C Code Style in interface.c

### Naming Conventions

- `QTS_` prefix for exported FFI functions (defined in interface.h, called from JavaScript)
- `qts_` prefix for internal C helper functions
- `static` keyword for file-local functions and variables
- Use `bool` from `<stdbool.h>` for boolean values (already included)

### Code Organization

- Section comments with `// ----` separators for logical grouping
- Forward declarations at the top of sections when needed
- Constants defined near related functions

### Error Handling Patterns

- Check `JS_IsException(value)` for error conditions
- Use `JS_GetException(ctx)` to retrieve the exception value
- Clean up resources in reverse order of allocation
- Return `JS_EXCEPTION` or `NULL` to signal errors to callers

### Example

```c
// ----------------------------------------------------------------------------
// Section Name

// Forward declaration
static JSValue qts_helper_function(JSContext *ctx, JSValueConst obj);

// Internal helper - not exported
static bool qts_check_something(JSContext *ctx, JSValueConst obj) {
  if (!JS_IsObject(obj)) return false;
  // ... implementation
  return true;
}

// Exported FFI function
JSValue *QTS_DoSomething(JSContext *ctx, JSValueConst *obj) {
  JSValue result = qts_helper_function(ctx, *obj);
  if (JS_IsException(result)) {
    return jsvalue_to_heap(JS_EXCEPTION);
  }
  return jsvalue_to_heap(result);
}
```
